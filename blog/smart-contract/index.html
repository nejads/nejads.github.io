<!doctype html><html dir=ltr lang=en data-theme=dark class="html theme--dark"><head><title>Sorosh Nejad
|
Exploring Solidity Vulnerabilities: Risks and Best Practices for Secure Smart Contracts</title><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Sorosh Nejad"><meta name=description content="Cloud engineer - Backend developer - AppSec speciallist"><link rel=stylesheet href=/scss/main.min.1147aa5bacb4bce677a0e264073829caedb82fd18ea07a5f1d80521f539d1c45.css integrity="sha256-EUeqW6y0vOZ3oOJkBzgpyu24L9GOoHpfHYBSH1OdHEU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://nejads.github.io/blog/smart-contract/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Exploring Solidity Vulnerabilities: Risks and Best Practices for Secure Smart Contracts"><meta name=twitter:description content="Definitions A blockchain is an append-only data structure which works on top of the peer-to-peer collection of nodes. Although Bitcoin is the most popular cryptocurrency and the most popular public ledger application, it has limited support for Smart contracts. The most famous framework for Smart contracts is Ethereum. [eth-smart-contract] A Smart contract is a computer program which a compiler can compile them to binary machine codes, written in a Turning-complete language like Solidity."><meta property="og:title" content="Exploring Solidity Vulnerabilities: Risks and Best Practices for Secure Smart Contracts"><meta property="og:description" content="Definitions A blockchain is an append-only data structure which works on top of the peer-to-peer collection of nodes. Although Bitcoin is the most popular cryptocurrency and the most popular public ledger application, it has limited support for Smart contracts. The most famous framework for Smart contracts is Ethereum. [eth-smart-contract] A Smart contract is a computer program which a compiler can compile them to binary machine codes, written in a Turning-complete language like Solidity."><meta property="og:type" content="article"><meta property="og:url" content="https://nejads.github.io/blog/smart-contract/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-07-12T09:13:51+02:00"><meta property="article:modified_time" content="2023-07-16T18:55:15+02:00"><meta property="og:site_name" content="Sorosh Nejad"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"Exploring Solidity Vulnerabilities: Risks and Best Practices for Secure Smart Contracts","headline":"Exploring Solidity Vulnerabilities: Risks and Best Practices for Secure Smart Contracts","alternativeHeadline":"","description":"
      
        Definitions A blockchain is an append-only data structure which works on top of the peer-to-peer collection of nodes. Although Bitcoin is the most popular cryptocurrency and the most popular public ledger application, it has limited support for Smart contracts. The most famous framework for Smart contracts is Ethereum. [eth-smart-contract] A Smart contract is a computer program which a compiler can compile them to binary machine codes, written in a Turning-complete language like Solidity.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/nejads.github.io\/blog\/smart-contract\/"},"author":{"@type":"Person","name":"Sorosh Nejad"},"creator":{"@type":"Person","name":"Sorosh Nejad"},"accountablePerson":{"@type":"Person","name":"Sorosh Nejad"},"copyrightHolder":{"@type":"Person","name":"Sorosh Nejad"},"copyrightYear":"2019","dateCreated":"2019-07-12T09:13:51.00Z","datePublished":"2019-07-12T09:13:51.00Z","dateModified":"2023-07-16T18:55:15.00Z","publisher":{"@type":"Organization","name":"Sorosh Nejad","url":"https://nejads.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/nejads.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/nejads.github.io\/blog\/smart-contract\/","wordCount":"2158","genre":[],"keywords":[]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/profile2.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Sorosh Nejad</a></div><div class=sidebar__introduction-description><p>Cloud engineer - Backend developer - AppSec speciallist</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://github.com/nejads target=_blank rel="noopener me" aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:nejads[@]me[.]com target=_blank rel="noopener me" aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://linkedin.com/in/nejads/ target=_blank rel="noopener me" aria-label=LinkedIn title=LinkedIn><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Sorosh Nejad, 2015-2024</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/blog/ title>Blog</a></li><li class=nav__list-item><a href=https://github.com/nejads/til target=_blank rel="noopener noreferrer" title>Today I Learned</a></li><li class=nav__list-item><a href=/about/ title>About</a></li><li class=nav__list-item><a href=/files/cv.pdf title>CV</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Exploring Solidity Vulnerabilities: Risks and Best Practices for Secure Smart Contracts</h1><h1 id=definitions>Definitions</h1><p>A blockchain is an append-only data structure which works on top of the peer-to-peer collection of nodes. Although Bitcoin is the most popular cryptocurrency and the most popular public ledger application, it has limited support for Smart contracts. The most famous framework for Smart contracts is Ethereum. [eth-smart-contract]
A Smart contract is a computer program which a compiler can compile them to binary machine codes, written in a Turning-complete language like Solidity.</p><h4 id=what-means-turning-complete-language>What means Turning-complete language?</h4><p>In computability theory, a system of data-manipulation rules (such as a computer&rsquo;s instruction set, a programming language, or a cellular automaton) is said to be Turing complete or computationally universal if it can be used to simulate any Turing machine. [\turing]
A Turing machine is a machine with unlimited random memory access and a finite set of instruction that dictates when it should read, write, and move across that memory and when it should terminate with a particular result. The input to a Turing machine is put in its memory before it starts and it will be read data before run instructions.
Alan Turing created &ldquo;Universal Turing Machine&rdquo; that can take any program and run it and show some result.
Programming languages are similar to the machines than Alan Turing created. They take programs written in their language and run them given enough time and memory.
Solidity is Turning complete language like other modern programming languages like Java, JavaScript, Perl. Solidity implements all the features required to run programs like addition, multiplication, if-else condition, return statements, ways to store/retrieve data on blockchain and so on.</p><h4 id=what-is-proof-of-work-or-mining-in-ethereum-network>What is proof-of-work or mining in Ethereum network?</h4><p>Proof-Of-Work in blockchain technology means nodes of the peer-to-peer network participate in a competition to append a new block of transactions. In this competition, the probability of winning is proportional to the &ldquo;hash-rate&rdquo; of the node. Hash rate is the computational power of a node in the network.
If a malicious node tries to append an incorrect block to the blockchain, the block will be eventually removed from the blockchain using a consensus protocol.</p><h4 id=consensus-protocol-in-ethererum>Consensus protocol in Ethererum.</h4><p>Conflicts in the approvement of the new blocks or the execution of contracts resolve by a &ldquo;consensus protocol&rdquo; based on proof-of-work puzzles.
Ethereum, at the moment, have no particular difference in validating new block of transactions, in comparison to other blockchain applications. Vitalik Buterin, the founder of Ethereum, says Ethereum may upgrade from Proof-of-work to Proof-of-stake in 2018. [ref needed]
The consensus protocol appoints miners to extend the branch with longest verified blocks. Hence, even though both branches can transiently continue to exist, eventually the fork will be resolved for the longest branch.</p><h4 id=the-relation-between-mining-and-smart-contracts>The relation between mining and smart contracts</h4><p>A &ldquo;necessary&rdquo; condition for smart contract effectiveness is the assumption of the correctness of the smart contract execution. Mining in the Ethernet guarantees that there is no fraudulent transaction lives on the network. Still, the accuracy of the smart contract execution is not &ldquo;sufficient&rdquo; for smart contract security.
Smart contracts have a financial value, so it is crucial to guarantee that the execution of the contracts performs correctly. In the traditional way of contracts in our world, the provider of the contracts relies on a trusted central authority like a government. But in the smart contracts, the provider (like Ethereum) relies on the vast network of mutually untrusted peers, called miners. Whenever a malicious does not have the majority of the hash rate of the network, we can assume that the execution of contracts is correct.</p><h4 id=execution-fees-and-ddos>Execution fees and DDOS</h4><p>A user upon each transaction must pay an execution fee to each miner who executes their contracts. This fees bound to the execution steps of contracts and preventing cumbersome and time-consuming computations run on the network. In that way, Ethereum prevents denial-of-service attacks where adversary nodes try to overwhelm a network.
If a contract consumes all the allocated gas, it throws an exception of type &ldquo;out-of-gas,&rdquo; and the caller loses all the gas.</p><h1 id=solidity-characteristics>Solidity Characteristics</h1><h4 id=exception-handling-in-solidity>Exception handling in Solidity</h4><p>Solidity implemented exception but with a particular behavior. A developer should be aware that that catching exception is not yet possible.
In some cases, exceptions are thrown automatically, but a developer can also throw an exception manually. When an exception throws, the execution stops, all changes to the state and the transfers of ether cryptocurrency reverts, and the execution fee will be lost. Solidity throws a runtime exception automatically in following cases: [\ethexception]</p><ul><li>If somebody access an array with a nonexisting index.</li><li>If you access a fixed-length byte N at a too large or negative index.</li><li>If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).</li><li>If you shift by a negative amount.</li><li>If you convert a value too big or negative into an enum type.</li><li>If you call a zero-initialized variable of internal function type.</li><li>If you call assert with an argument that evaluates to false.</li><li>(? More research on the exception handling in Solidity. Compare with other languages.)</li></ul><h4 id=global-variables-in-blockchain>Global variables in Blockchain</h4><p>The problem is that Solidity does not introduce constructs to deal with domain-specific aspects, like, e.g., the fact that computation steps are recorded on a public blockchain, wherein they can be unpredictably reordered or delayed. Here will we define the global variable and shared state in Ethereum which we have used in the project.</p><p><strong>Outflow</strong>: A hash table which records all the addresses. Addresses are 160 bits and can identify contracts and user addresses. Pitfalls with addresses are that first; we can not find out an address is belong to a user or a contract. Second, we can not find out that an address is dead and unusable before we run the contract.</p><p><strong>Balance</strong>: shows the balance of a wallet. Balance is a unique variable which cannot be altered by smart contract developers. Furthermore, contracts cannot define a variable called balance.</p><p><strong>this</strong>: The address of currect contract.</p><h4 id=fallback-functions>fallback functions</h4><p>Fallback functions will be triggered when the invoked function signature does not match any of the available functions in a contract.</p><h1 id=solidity-vulnerabilities>Solidity vulnerabilities</h1><p>A significant part of all vulnerabilities is related to Solidity; the high-level programming language looks like a typed Javascript language, supported by Ethereum. Analysing vulnerabilities related to Solidity needs to understand the structure of the language and how to compile and how a byte-code run on different nodes on Ethereum network parallelly.</p><h4 id=call-to-the-unknown>Call to the unknown</h4><p>Some of the primitives used in Solidity to invoke functions and to transfer ether may have the side effect of invoking the fallback function of the callee/recipient. For example,</p><ol><li>Call method
Which can be used to invoke a service from another contract, or from the contract itself. If the invocation of a method does not exist at the given address, then the fallback function of the callee is executed, instead.
For example, if you do TestAddress.call(bytes32(sha3(&ldquo;testFunction(uint,bytes32)&rdquo;)), 2), then the EVM will try to match &ldquo;testFunction&rdquo; at that &ldquo;TestAddress&rdquo;. If the function does not exist in the invoked contract, then the fallback function will be triggered.
Consider following example:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>contract ContractA {
</span></span><span style=display:flex><span>  function() { x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; }
</span></span><span style=display:flex><span>  uint x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>contract CallerContract {
</span></span><span style=display:flex><span>  function callTest(address testAddress) {
</span></span><span style=display:flex><span>    ContractA(testAddress)<span style=color:#f92672>.</span>call(<span style=color:#e6db74>&#39;0xqwertyu87&#39;</span>); <span style=color:#f92672>//</span> hash does <span style=color:#f92672>not</span> exist
</span></span><span style=display:flex><span>    <span style=color:#f92672>//</span> results of calling ContractA(testAddress), x becoming <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The caller function invoked a function with the specifying hash signature which does not exist in ContractA so the fallback function of the ContractA has invoked instead and the value of the variable x has become 0 which is an undesired value.</p><ol start=2><li>Send
The &ldquo;send&rdquo; method is used to transfer Ether from contracts to some recipients. The &ldquo;send&rdquo; method executes the recipient&rsquo;s fallback method after the Ether has been transferred. It leads to a potential security risk. Take the following example into consideration.
Imagine Alice has a company running on Ethereum, and money distribution is to be paid in Ether to the owners. Imagine there are ten owners. When using send(), the fallback function is triggered. There is no recognization between a regular address and an address associated with a contract in the EVM. Sends are working fine, until owner 5. From the sender perspective, all the gas gets finished, and other transaction fails. No one else gets paid.
What happened here is that owner five executed a malicious piece of code. He used a contract address instead of her wallet address, and in its fallback function of the contract performed an infinite loop. All the gas gets used, and thus it is not possible to send any money without removing owner five as a shareholder.
The problem with send() described above, was a fundamental problem to one-sidedly trusting another part of code on Ethereum network, especially when using send(). The following solution is applied to fix especially send() method problem:</li></ol><ul><li>Send() does not forward gas anymore. It merely uses the hardcoded stipend (2300 gas) siphoned from the value transfer cost (minimum 9040). It&rsquo;s enough to send Ether but also enough to do one additional small logging operation. You can&rsquo;t do another value transfer (it costs minimum 9040 gas), and you can&rsquo;t do things like storing variables.</li><li>Send() does not throw an error in the case runs out of gas, it only returns false.</li></ul><p>With this fix, you can now use send() safely in the above example. The malicious user (user five) uses up its allotted gas stipend in this case, and it returns false. All the other transactions simply continue, and everyone gets paid properly.</p><ol start=3><li>Delegate call
DELEGATECALL fundamentally is similar to CALL with a difference which is the invocation of the invoked function will be run in the caller environment. It merely says that I&rsquo;m a contract and I&rsquo;m delegating you to do whatever you want to my storage.
DELEGATECALL is a potential security vulnerability for the sending contract which needs to trust that the receiving part will treat the storage well.
DELEGATECALL was a new opcode that was a bug fix for CALL-CODE which did not preserve msg.sender and msg.value. If Alice invokes Bob who does DELEGATECALL to Charlie, the msg.sender in the DELEGATECALL is Alice (whereas if CALL-CODE was used the msg.sender would be Bob).</li></ol><p>With the following example, we will illustrate the difference between call and delegate call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>contract ToBeCalledContract {
</span></span><span style=display:flex><span>    event callMeEvent(address _from);
</span></span><span style=display:flex><span>    function callMe() payable public {
</span></span><span style=display:flex><span>        callMeEvent(this);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>contract CallerContract {
</span></span><span style=display:flex><span>    function callTheOtherContract(address _contractAddress) public {
</span></span><span style=display:flex><span>        require(_contractAddress<span style=color:#f92672>.</span>call(bytes4(keccak256(<span style=color:#e6db74>&#34;callMe()&#34;</span>))));
</span></span><span style=display:flex><span>        require(_contractAddress<span style=color:#f92672>.</span>delegatecall(bytes4(keccak256(<span style=color:#e6db74>&#34;callMe()&#34;</span>))));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Call() method will invoke the function in the contract that you are trying to call. We don&rsquo;t need to know the interface correctly; we only should know that the contract has a function called with a specific name, &ldquo;callMe&rdquo; in our example. If we do this, it&rsquo;s like invoking an instance of the invoked contract and in our case ToBeCalledContract which will fire an event called &ldquo;callMeEvent&rdquo;. Additionally, The global variable &ldquo;this&rdquo; takes the ToBeCalledContract address. Here&rsquo;s the big difference to delegate-call. Delegate-call will behave like you import the code from ToBeCalledContract into CallerContract. The &ldquo;this&rdquo; variable emit the CalletContract address when we use delegate-call. So call() will emit the address from the invoked contract, and delegate-call emit the address from the invoking contract.</p><h4 id=exception-disorders>Exception disorders</h4><p>There are several conditions where an exception may be thrown in solidity. For example, if the execution runs out of gas, it leads to NoGasException or the call stack reaches its limit, or the command &ldquo;throw&rdquo; is performed. However, handle an exception in Solidity is not uniform. There are two different behaviors, which depend on how contracts call each other.
We can catogoriThis two different behaviors. We categorize this two different behaviors. Imagine there is a chain of nested calls. Solidity handle exception as follows:</p><ol><li>If all elements of the chain are &ldquo;direct call,&rdquo; then the execution stops and all transfer of Ether is reverted, but all the gas allocated by transactions is consumed.
An example of the &ldquo;direct call&rdquo;:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>contract ContractA {
</span></span><span style=display:flex><span>  { function test(uint) returns (uint)  }
</span></span><span style=display:flex><span>  uint x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>contract CallerContract {
</span></span><span style=display:flex><span>  function directCallTest() {
</span></span><span style=display:flex><span>    uint check <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    function directCall(ContractA a) {check<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; a<span style=color:#f92672>.</span>test(<span style=color:#e6db74>&#34;ERROR&#34;</span>); check<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The test will be throw an exception and whole transaction reverted so the value of the &ldquo;check&rdquo; variable contains 0.</p><ol start=2><li>If there is a &ldquo;call&rdquo; (or send, or Delegate-call) method in the chain of calls, then the exception spreads along the chain, and all contract reverted until reaches the &ldquo;call&rdquo; function. That &ldquo;call&rdquo; function returns false, and the gas allocated to the &ldquo;call&rdquo; function is consumed. So the function that invoked the &ldquo;call&rdquo; function takes no side effect of the exception. Preferably, it should check the returning value of the &ldquo;call&rdquo; function.
In the example, if we use &ldquo;call&rdquo; to ContractA&rsquo;s test method, then the exception will be thrown and the returning value of the call function will be false but the transaction in CallerContract will be performed and the &ldquo;check&rdquo; variable contains 2.</li></ol><h1 id=references>References:</h1><p>\eth-smart-contract: Buterin, V.: Ethereum: a next-generation smart contract and decentralized application
platform. <a href=https://github.com/ethereum/wiki/wiki/White-Paper>https://github.com/ethereum/wiki/wiki/White-Paper</a> (2013)
\ethexception <a href=http://solidity.readthedocs.io/en/v0.4.21/control-structures.html#error-handling-assert-require-revert-and-exceptions>http://solidity.readthedocs.io/en/v0.4.21/control-structures.html#error-handling-assert-require-revert-and-exceptions</a></p><p>\eth-send-fallback <a href=https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send()-in-Ethereum-&-Solidity>https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send()-in-Ethereum-&-Solidity</a>
\turing <a href=https://en.wikipedia.org/wiki/Turing_completeness>https://en.wikipedia.org/wiki/Turing_completeness</a></p></div><div class=post__footer></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Sorosh Nejad, 2015-2024</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>